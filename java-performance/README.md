
**《高性能Java系统权威指南》 ，2022年12月出版**

* 本书代码最新地址 https://gitee.com/xiandafu/java-performance 
* 每章的readme.md 包含了主要代码的说明


# 书中章节

```
第1章 Java代码优化	
    1.1　可优化的代码	
    1.2　性能监控	
    1.3　JMH
        1.3.1　使用JMH	
        1.3.2　JMH常用设置	
        1.3.3　注意事项	
        1.3.4　单元测试
第2章 字符串和数字操作	
    2.1　构造字符串	
    2.2　字符串拼接	
    2.3　字符串格式化	
    2.4　字符串查找	
    2.5　替换	
    2.6　intern方法	
    2.7　UUID	49
    2.8　StringUtils类	
    2.9　前缀树过滤	
    2.10　数字装箱	
    2.11　BigDecimal
第3章 并发编程和异步编程		 
    3.1　不安全的代码	
    3.2　Java并发编程	
        3.2.1　volatile	
        3.2.2　synchronized	
        3.2.3　Lock	
        3.2.4　Condition	
        3.2.5　读写锁	
        3.2.6　Semaphore	
        3.2.7　栅栏	
    3.3　Java并发工具	
        3.3.1　原子变量	
        3.3.2　Queue	
        3.3.3　Future	
        3.3.4　ThreadLocal	
    3.4　Java线程池	
    3.5　异步编程	
        3.5.1　创建异步任务	
        3.5.2　任务完成后执行回调	
        3.5.3　串行执行	
        3.5.4　并行执行	
        3.5.5　接收任务处理结果
第4章	代码性能优化	
    4.1　int转String	
    4.2　使用Native方法	
    4.3　日期格式化	
    4.4　switch优化	
    4.5　优先使用局部变量	
    4.6　预处理	
    4.7　预分配	
    4.8　预编译	
    4.9　预先编码	
    4.10　谨慎使用Exception
    4.11　批处理	
    4.12　展开循环	
    4.13　静态方法调用
    4.14　高速Map存取	
    4.15　位运算	
    4.16　反射	
    4.17　压缩	
    4.18　可变数组
    4.19　System.nanoTime()	
    4.20　ThreadLocalRandom	
    4.21　Base64	
    4.22　辨别重量级对象
    4.23　池化技术	
    4.24　实现hashCode	
    4.25　错误优化策略	
        4.25.1　final无法帮助内联	
        4.25.2　subString内存泄漏	
        4.25.3　循环优化	
        4.25.4　循环中捕捉异常
第5章 高性能工具
    5.1　高速缓存Caffeine	
        5.1.1　安装Caffeine	
        5.1.2　Caffeine的基本使用方法	
        5.1.3　淘汰策略	
        5.1.4　statistics功能	
        5.1.5　Caffeine高命中率	
        5.1.6　卓越的性能	
    5.2　映射工具Selma	
    5.3　JSON工具Jackson	
        5.3.1　Jackson的三种使用方式	
        5.3.2　Jackson树遍历	
        5.3.3　对象绑定	
        5.3.4　流式操作	
        5.3.5　自定义JsonSerializer	
        5.3.6　集合的反序列化	
        5.3.7　性能提升和优化	
    5.4　HikariCP	
        5.4.1　安装HikariCP	
        5.4.2　HikariCP性能测试	
        5.4.3　性能优化说明	
    5.5　文本处理工具Beetl	
        5.5.1　安装和配置	
        5.5.2　脚本引擎	
        5.5.3　Beetl的特点	
        5.5.4　性能优化	
    5.6　MessagePack	
    5.7　ReflectASM	
第六章 可读性代码	
    6.1　精简注释	
    6.2　变量	
        6.2.1　变量命名	
        6.2.2　变量的位置	
        6.2.3　中间变量	
    6.3　方法	
        6.3.1　方法签名	
        6.3.2　短方法	
        6.3.3　单一职责	
    6.4　分支	
        6.4.1　if else	
        6.4.2　switch case	
    6.5　发现对象	
        6.5.1　不要使用String	
        6.5.2　不要用数组、Map	
    6.6　checked异常（可控异常）	
    6.7　其他事项	
        6.7.1　避免自动格式化	
        6.7.2　关于Null
第7章　JIT优化	
    7.1　编译Java代码	
    7.2　处理语法糖	
    7.3　解释执行和即时编译	
    7.4　C1和C2	
    7.5　代码缓存	
    7.6　JITWatch	
    7.7　内联	
    7.8　虚方法调用
第8章　代码审查	281
    8.1　ConcurrentHashMap陷阱	
    8.2　字符串搜索	
    8.3　I/O输出	
    8.4　字符串拼接	
    8.5　方法的入参和出参	
    8.6　RPC调用定义的返回值	
    8.7　Integer的使用	
    8.8　排序	
    8.9　判断特殊的ID	
    8.10　优化if结构	
    8.11　文件复制	
    8.12　switch优化	
    8.13　Encoder	
    8.14　一个JMH例子	
    8.15　注释	
    8.16　完善注释	
    8.17　方法抽取	
    8.18　遍历Map	
    8.19　日期格式化	
    8.20　日志框架	
    8.21　持久化到数据库	
    8.22　某个RPC框架	
    8.23　循环调用	
    8.24　lock的使用	
    8.25　字符集	
    8.26　处理枚举值	
    8.27　任务执行	
    8.28　开关判断	
    8.29　JDBC操作	
    8.30　Controller代码	
    8.31　停止任务	
    8.32　缩短UUID	
第9章　Java字节码	
    9.1　Java字节码	
        9.1.1　基础知识	
        9.1.2　.class文件的格式	
    9.2　Java方法的执行	
        9.2.1　方法在内存中的表示	
        9.2.2　方法在.class文件中的表示	
        9.2.3　指令的分类	
        9.2.4　HelloWorld字节码分析	
        9.2.5　字符串拼接字节码分析	
    9.3　字节码IDE插件	
    9.4　ASM入门	
        9.4.1　生成类名和构造函数	
        9.4.2　生成main方法	
        9.4.3　调用生成的代码	
    9.5　ASM增强代码	
        9.5.1　使用反射实现	
        9.5.2　使用ASM生成辅助类	
        9.5.3　switch语句的分类	
        9.5.4　获取Bean中的property	
        9.5.5　switch语句的实现	
        9.5.6　性能对比
第10章　JVM调优	
    10.1　JVM内存管理	
        10.1.1　JVM内存区域	
        10.1.2　堆内存区域	
    10.2　垃圾回收：自动内存管理	
        10.2.1　垃圾自动回收	
        10.2.2　Serial GC	
        10.2.3　Parallel GC	
        10.2.4  CMS GC	
        10.2.5  G1 GC	
    10.3　JVM参数设置	
        10.3.1　从GC Log入手	
        10.3.2　堆大小设置建议	
        10.3.3　其他参数的设置	
    10.4　内存分析工具	
        10.4.1　jstat命令	
        10.4.2　jmap命令	
        10.4.3　GCeasy	
        10.4.4　JMC	
        10.4.5　MAT	
        10.4.6　OQL	
    10.5　内存故障案例分析	
    10.5.1　一个简单例子	
    10.5.2　线程池优化导致内存泄漏	
    10.5.3　finalize引发的严重事故	
    10.5.4　C++动态库导致的内存泄漏	
                 			
```

